# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/concurrent-ruby/all/concurrent-ruby.rbi
#
# concurrent-ruby-1.2.2

module Concurrent
  extend Concurrent::Utility::EngineDetector
end
module Concurrent::Utility
end
module Concurrent::Utility::EngineDetector
  def on_cruby?; end
  def on_jruby?; end
  def on_linux?; end
  def on_osx?; end
  def on_truffleruby?; end
  def on_windows?; end
  def ruby_version(version = nil, comparison, major, minor, patch); end
end
module Concurrent::Collection
end
class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def dupped_backend; end
  def each_pair; end
  def get_and_set(key, value); end
  def get_or_default(key, default_value); end
  def initialize(options = nil, &default_proc); end
  def initialize_copy(other); end
  def key?(key); end
  def merge_pair(key, value); end
  def pair?(key, expected_value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
  def set_backend(default_proc); end
  def size; end
  def store_computed_value(key, new_value); end
end
class Concurrent::Collection::MriMapBackend < Concurrent::Collection::NonConcurrentMapBackend
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def get_and_set(key, value); end
  def initialize(options = nil, &default_proc); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
end
class Concurrent::Map < Concurrent::Collection::MriMapBackend
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(key, default_value = nil); end
  def fetch_or_store(key, default_value = nil); end
  def get(key); end
  def initialize_copy(other); end
  def inspect; end
  def key(value); end
  def keys; end
  def marshal_dump; end
  def marshal_load(hash); end
  def populate_from(hash); end
  def put(key, value); end
  def put_if_absent(key, value); end
  def raise_fetch_no_key; end
  def validate_options_hash!(options); end
  def value?(value); end
  def values; end
end
module Concurrent::ThreadSafe
end
module Concurrent::ThreadSafe::Util
end
class Concurrent::Hash < Hash
end
